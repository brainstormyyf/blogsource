---
type: docs
title: 第一章：操作系统引论
linkTitle: 操作系统引论
date: 2024-02-14T01:39:18+08:00
draft: false
nav_weight: 1
series:
  - 408
tags:
  - 操作系统
images:
authors:
  - YYF
---

<!--more-->

## 一、操作系统的基本概念

### 1. 操作系统的特征

#### (1)并发

- <span style="background:#fff88f">并发：同一时间间隔内发生</span>
- <span style="background:#fff88f">并行：同一时刻发生</span>

{{< bs/alert danger >}}
并发，并行的区别辨析非常重要
{{< /bs/alert >}}

#### (2)共享(资源共享方式)

- 互斥共享
  - 一段时间内只允许一个进程访问该资源（打印机、磁带机）
  - 临界资源（独占资源）：一段时间内只允许一个进程访问的资源
- 同时访问
  - 一段时间内允许多个进程访问该资源（磁盘、可重入代码）

#### (3)虚拟

空分复用技术是指在物理内存（主存）不够用时，通过将部分数据暂时存储到磁盘上的虚拟内存中，从而在逻辑上扩展了存储器的容量。这样，多个程序可以共享物理内存，每个程序都认为自己拥有连续的、足够的内存空间，而实际上它们的地址空间是交叉存储的，这种技术使得多个程序可以同时运行，而不会相互干扰。
时分复用技术是指将时间分片，轮流分给各个用户或者进程使用，通常用于处理器的分配，如多道程序设计中的时间共享，允许操作系统在很短的时间内切换多个任务，使得每个任务都感觉自己在连续不断地使用处理器。

总结来说，虚拟存储器使用的是空分复用技术，而虚拟处理机使用的是时分复用技术。

| 复用技术     | 示例                                                                                                                                   |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| 时分复用技术 | 虚拟处理机（多道程序并发执行分时使用一个处理器）、虚拟设备（spooling技术将一台物理设备虚拟为多台逻辑设备，从而将独占设备变为共享设备） |
| 空分复用技术 | 虚拟存储器（从逻辑上扩展了存储器的容量）                                                                                               |

{{< bs/alert info >}}
实际上虚拟存储器既用了时分复用技术，又用了空分复用技术。
</br></br> <font color="#c00000">空分复用技术</font>体现在虚拟存储器允许将物理内存（RAM）和磁盘存储（通常是硬盘）结合起来使用，形成一个连续的、统一的地址空间。这样，程序的地址空间可以远远大于实际的物理内存大小，因为不常用的数据可以暂时存储在磁盘上，只在需要时才加载到内存中。这种技术使得多个程序可以共享有限的物理内存资源，提高了内存的使用效率。
</br> </br><font color="#c00000">时分复用技术</font>体现在虚拟存储器的管理上。由于物理内存的大小是有限的，操作系统需要不断地在内存中的程序和数据之间进行切换，以保持所有活动程序的进展。这种切换类似于时分复用技术中的时间片轮转，只不过它是基于内存页面的换入和换出，而不是基于CPU时间片的切换。操作系统会根据程序的访问模式和内存需求，动态地将内存页面在物理内存和磁盘之间移动，这要求操作系统具有高效的数据换入换出算法，如LRU（最近最少使用）算法等。
</br></br> 因此，虚拟存储器同时利用了空分复用技术来扩展地址空间，以及时分复用技术来有效管理有限的物理内存资源。这两种技术的结合，使得虚拟存储器能够提供大容量的地址空间，并且高效地使用有限的物理内存
{{< /bs/alert >}}

#### (4)异步

- 进程走走停停，以人们不可预知的速度推进

### 2. 操作系统的目标和功能

**（1）计算机系统资源的管理者**

- 处理机管理、存储器管理、文件管理、设备管理（后面章节细讲）

**（2）用户与计算机硬件系统的接口**

| 接口类型                                    | 接口子类型   | 描述                                                                                                    | 适用场景                       |
| ------------------------------------------- | ------------ | ------------------------------------------------------------------------------------------------------- | ------------------------------ |
| 用户接口                                    | 联机用户接口 | 一次一句                                                                                                | 分时系统、实时系统             |
| 用户接口                                    | 脱机用户接口 | 一次一批                                                                                                | 批处理系统                     |
| 用户接口                                    | 图形用户接口 | 使用图形元素（如按钮、窗口）进行交互                                                                    | 个人电脑、图形界面操作系统     |
| <span style="background:#b1ffff">程序接口<span> |              | <span style="background:#fff88f">是用户程序取得操作系统服务的唯一途径，由一组系统调用（广义指令）组成<span> | 所有需要操作系统服务的用户程序 |

**（3）对计算机资源的扩充**

- 没有任何软件的计算机称为裸机；覆盖了软件的计算机称为扩充机器或虚拟机

## 二、操作系统发展历程

### 1. 手工操作阶段

- 程序的装入、运行、结果的输出等所有工作都需要人工干预，资源利用率低，CPU利用不充分

### 2. 批处理系统

| ———`<br>` | 单道批处理系统                                                                                                                 | 多道批处理系统                                                                       |
| --------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------ |
| 前提      | -                                                                                                                              | <span style="background:#fff88f">中断技术和通道技术，让CPU和外设能并行工作（2016）<span> |
| 特点      | 1.自动性：磁带上的一批作业能自动逐个运行<br>2.顺序性：磁带上的作业顺序进入内存执行完成<br>3.单道性：内存中仅有一道程序运行 | 1.多道性：内存中有多道程序交替运行`<br>2.宏观上并行，微观上串行                     |
| 优点      | 相比手工操作系统提高了资源利用率                                                                                               | <span style="background:#fff88f">资源利用率高、CPU利用充分、系统吞吐量大（2017）<span>   |
| 缺点      | 资源利用率还是低                                                                                                               | 用户响应时间长，不提供人机交互能力（相比于分时系统而言）                             |

### 3. 分时操作系统

- 定义：把处理器的运行时间分片，按时间片轮流把处理器分配给各个作业使用
- 特点：人机交互，多用户共享主机，响应速度快

### 4. 实时操作系统

- 目标：及时性、可靠性
- 特点：资源利用率较低、一般使用高优先级抢占式调度算法
- 分类
  - 硬实时系统（工业、武器、飞行器控制）
  - 软实时任务（飞机订票系统、银行管理系统、信息查询系统）

### 5. 网络操作系统、分布式计算机系统、个人操作系统

- 略微了解

## 三、操作系统运行环境

### 1. 处理器运行模式

**(1)指令类别**

| 指令类别   | 描述                     | 示例                                                                                                                     |
| ---------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| 特权指令   | 不允许用户直接使用的指令 | <span style="background:#fff88f">I/O指令、置中断、设置系统时间、存取用于内存保护的寄存器、清理内存、修改权限、进程切换<span> |
| 非特权指令 | 在用户态可以运行的指令   | <span style="background:#fff88f">读写内存、算术运算、命令解释程序<span>                                                      |

{{< bs/alert info >}}
寄存器清零无法判断是特权指令还是非特权指令
{{< /bs/alert >}}

**(2)CPU运行模式**

| CPU运行模式            | 运行的程序和指令类别                   |
| ---------------------- | -------------------------------------- |
| 用户态（目态）         | 用户自编程序和非特权指令运行在用户态   |
| 内核态（管态、核心态） | 操作系统内核程序和特权指令运行在内核态 |

**(3)转换**

- 内核态-->用户态
  - 执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权
- 用户态-->内核态
  - 由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权

**(4)时钟管理**

- 向用户提供标准的系统时间
- 分时系统中时间片轮转调度
- 实时系统中按截止时间控制运行
- 批处理系统中衡量一个作业的运行程度

**(5)中断机制**

- <span style="background:#fff88f">子程序调用只保存PC;中断程序需要保存PC和PSW（2012）</span>
- <span style="background:#fff88f">由硬件找到中断向量表，但中断向量表的初始化由操作系统完成（2020）</span>

**(6)原语操作**

- 由若干指令组成的、用于完成一定功能的一个过程
- 执行过程中不允许被中断（可以通过关中断方法实现）
- 原子操作在系统态下执行，常驻内存

### 2. 中断和异常的概念

**(1)内部异常**

| 分类方式       | 类别           | 描述                                       | 示例                                                      |
| -------------- | -------------- | ------------------------------------------ | --------------------------------------------------------- |
| 发生原因       | **硬故障中断** | 硬件线路出现异常                           | 电源掉电、存储器线路错误                                  |
| 发生原因       | **程序性异常** | CPU执行某个指令引起                        | 溢出、地址越界、整数除零、非法指令、时间片中断、单步跟踪  |
| 报告和返回方式 | **故障**       | 操作系统检测到的错误                       | 非法操作码、缺段缺页、整数除零、保护错                    |
| 报告和返回方式 | **陷入**       | 程序执行到特定点时故意引发的中断           | 程序调试断点、系统调用（用户程序的I/O请求）、条件自陷指令 |
| 报告和返回方式 | **终止**       | 需要操作系统进行干预来停止程序的执行的中断 | 电源掉电、线路故障                                        |

**(2)中断（外中断）**

<span style="background:#fff88f">示例：I/O设备中断、定时器到时、时钟中断、打印机缺纸、磁盘缓冲满</span>

| 阶段         | 操作                   | 详情                                                       |
| ------------ | ---------------------- | ---------------------------------------------------------- |
| 硬件完成     | 关中断                 | 防止其他中断打断当前中断的处理过程                         |
|              | 保存断点（PC和PSW）    | 记录下被中断的程序计数器和程序状态字                       |
|              | 识别中断源             | 确定是哪个设备或事件触发了中断                             |
| 操作系统完成 | 保护现场（寄存器信息） | 保存当前执行的程序的寄存器值，以便中断服务完成后能够恢复   |
|              | 屏蔽字                 | 根据需要设置屏蔽字，控制哪些中断可以被响应，哪些需要被忽略 |
|              | 执行中断服务程序       | 调用相应的中断处理程序来响应和处理中断请求                 |

{{< bs/alert danger >}}
中断和异常的概念辨析非常重要！！！异常和中断是操作系统处理意外或特定事件时使用的两种机制，它们有一些关键的区别：
{{< /bs/alert >}}

1. **来源不同**：
   - **中断**（Interrupt）通常是由<span style="background:#fff88f">外部设备</span>发出的信号，通知CPU有一个需要立即处理的紧急事件。例如，当用户输入数据时，键盘会产生一个中断信号。
   - **异常**（Exception）是由CPU在<span style="background:#fff88f">执行内部指令</span>时产生的，通常是因为内部错误或程序执行了某些特殊的指令（如系统调用）。异常是同步发生的，即在指令执行期间或之后立即被识别和处理的。
2. **处理方式不同**：
   - 中断通常是异步的，它们的处理程序需要能够处理随机发生的中断，并且在处理中断时可能需要保存当前处理的上下文（如程序计数器和其他寄存器的值），以便之后能够恢复被中断的任务。
   - 异常是同步的，它们在特定的指令执行时被触发，操作系统在处理异常时通常不需要保存和恢复上下文，因为异常是在控制流顺序中的。
3. **类型划分不同**：
   - 中断可以分为可屏蔽中断和非可屏蔽中断。可屏蔽中断可以被CPU忽略，而非可屏蔽中断则必须立即处理。
   - 异常可以分为多种类型，如硬件故障导致的故障、程序执行了非法操作码导致的陷阱、程序请求操作系统服务时的系统调用等。
4. **目的不同**：
   - 中断的目的是为了响应外部事件，如I/O请求、时钟信号等。
   - 异常的目的是为了处理程序执行中的错误或特殊请求。
     总的来说，中断和异常都是操作系统用来处理不同类型事件的重要机制，它们在处理时机、来源和处理方式上有所不同。操作系统需要通过合理地处理这些事件来保证系统的稳定性和响应性。

总结为如下表格：

| 特征     | 中断                                | 异常                           |
| -------- | ----------------------------------- | ------------------------------ |
| 来源     | 外部设备信号                        | CPU执行指令时产生的内部事件    |
| 发生方式 | 异步                                | 同步                           |
| 处理方式 | 需保存和恢复上下文                  | 通常不需要保存和恢复上下文     |
| 类型     | 可屏蔽/非可屏蔽                     | 故障、陷阱、系统调用等         |
| 目的     | 响应外部事件（如I/O请求、时钟信号） | 处理程序执行中的错误或特殊请求 |

### 3. 系统调用(广义指令)

- 系统调用过程
  - （传递调用参数、执行陷入指令、执行服务程序、返回用户态）

![](https://gitee.com/yao_yi_feng/fighouse/raw/master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/git/202402211739717.webp?width=700#center)

- 特点
  - <span style="background:#fff88f">系统调用是操作系统提供给应用程序的接口（2010、2019）</span>
  - 每个系统有许多系统调用，每个系统调用有唯一的系统调用号
  - <span style="background:#fff88f">一个操作系统所有的系统调用都通过一个中断入口来实现，不同操作系统为用户提供的系统调用接口不同（2019）</span>
  - <span style="background:#fff88f">在执行系统调用服务程序的过程中，CPU处于内核态（2019）</span>
  - 系统调用只能通过用户程序间接使用
- 访管指令
  - 名称：访管指令、陷入指令、trap指令
  - 在用户态使用，不是特权指令，用户程序借此发起系统调用
  - 广义指令的调用可能在用户态，但执行一定在内核态

## 四、操作系统结构

![](https://gitee.com/yao_yi_feng/fighouse/raw/master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/git/202402211333254.webp)

## 五、操作系统引导

![](https://gitee.com/yao_yi_feng/fighouse/raw/master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/git/202402211739588.webp)

**步骤描述：**

- ①激活CPU。激活的CPU读取 ROM中的 boot（自举）程序，开始执行BIOS的指令
- ②硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障
- ③加载带有操作系统的硬盘。BIOS读取Boot Sequence，然后CPU将存储设备引导扇区的内容加载到内存中
- ④加载主引导记录 MBR。轮流查找引导硬盘（主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统）
- ⑤扫描硬盘分区表并加载硬盘活动分区。主引导记录扫描硬盘分区表，识别并加载含有操作系统的硬盘分区（活动分区)
- ⑥加载分区引导记录PBR。读取分区引导记录(PBR)，其作用是寻找并激活分区根目录下用于引导操作系统的启动管理器
- ⑦加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器
- <span style="background:#fff88f">⑧加载操作系统到内存RAM（2013）</span>

{{< bs/alert warning >}}
引导程序分为两种，分别是位于ROM中的自举程序和位于引导扇区的启动管理器。
操作系统引导只是将操作系统内核加载到内存，其它部分仅在需要时才调入。
{{< /bs/alert >}}

## 六、虚拟机

![](https://gitee.com/yao_yi_feng/fighouse/raw/master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/git/202402211739676.webp?width=600#center)

- 虚拟内核态：虚拟机上的操作系统认为自己运行在内核态（并不是）
- 用户态：虚拟机中的用户进程认为自己运行在用户态（确实是）
- 描述

  - 虚拟机可以用软件实现也可以用硬件实现
  - 虚拟机是运行在计算机中的一个应用程序
  - 真实硬件不会执行虚拟机中的敏感指令
